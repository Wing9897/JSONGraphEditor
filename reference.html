<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Graph Editor v10.0 - ÂÆåÊï¥ÈáçÊñ∞Ë®≠Ë®à</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .graph-container { overflow: hidden; }
        .slot-dot { cursor: pointer; transition: all 0.2s ease; }
        .slot-dot:hover { stroke-width: 3; transform: scale(1.2); }
        .connection-line { fill: none; stroke-width: 2; }
        .slot-connection { 
            stroke: #8b5cf6; 
            stroke-dasharray: none; 
            filter: drop-shadow(0 2px 4px rgba(139, 92, 246, 0.3));
        }
        .parent-child-connection {
            stroke: #999;
            stroke-dasharray: 5,5;
            opacity: 0.7;
        }
        .node-rect { cursor: move; transition: all 0.2s ease; }
        .node-rect:hover { stroke-width: 2; transform: scale(1.02); }
        .complex-box { box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .table-cell { 
            stroke: #e5e7eb; 
            stroke-width: 1; 
            fill: white; 
        }
        .table-cell:nth-child(even) { 
            fill: #f9fafb; 
        }
        .table-header { 
            fill: #f3f4f6; 
            stroke: #d1d5db; 
            font-weight: bold; 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // =====================================
        // üìã Ê†∏ÂøÉÊï∏ÊìöÁÆ°ÁêÜÁ≥ªÁµ±
        // =====================================
        
        /**
         * Êï∏ÊìöËÆäÊõ¥‰∫ã‰ª∂ÁÆ°ÁêÜÂô®
         * Ë≤†Ë≤¨ÂçîË™øÊâÄÊúâÁ∑®ËºØÂô®‰πãÈñìÁöÑÊï∏ÊìöÂêåÊ≠•
         */
        class DataChangeManager {
            constructor(initialData, onDataChange) {
                this.currentData = initialData;
                this.onDataChange = onDataChange;
                this.subscribers = new Set();
                this.isUpdating = false;
                this.updateQueue = [];
            }
            
            // Ë®ªÂÜäË®ÇÈñ±ËÄÖ
            subscribe(subscriber) {
                this.subscribers.add(subscriber);
                return () => this.subscribers.delete(subscriber);
            }
            
            // Êõ¥Êñ∞Êï∏Êìö
            async updateData(newData, source = 'unknown') {
                if (this.isUpdating) {
                    this.updateQueue.push({ newData, source });
                    return;
                }
                
                this.isUpdating = true;
                
                try {
                    console.log(`[DataManager] Êï∏ÊìöÊõ¥Êñ∞‰æÜÊ∫ê: ${source}`);
                    this.currentData = newData;
                    
                    // ÈÄöÁü•Áà∂ÁµÑ‰ª∂
                    if (this.onDataChange) {
                        this.onDataChange(newData);
                    }
                    
                    // ÈÄöÁü•ÊâÄÊúâË®ÇÈñ±ËÄÖÔºå‰ΩÜË∑≥ÈÅéÊõ¥Êñ∞‰æÜÊ∫ê
                    this.subscribers.forEach(subscriber => {
                        if (subscriber.id !== source) {
                            subscriber.onDataChange(newData);
                        }
                    });
                    
                } finally {
                    this.isUpdating = false;
                    
                    // ËôïÁêÜÈöäÂàó‰∏≠ÁöÑÊõ¥Êñ∞
                    if (this.updateQueue.length > 0) {
                        const { newData: queuedData, source: queuedSource } = this.updateQueue.shift();
                        setTimeout(() => this.updateData(queuedData, queuedSource), 0);
                    }
                }
            }
            
            // Áç≤ÂèñÁï∂ÂâçÊï∏Êìö
            getCurrentData() {
                return this.currentData;
            }
        }

        // =====================================
        // üéØ ‰∏ªÊáâÁî®ÁµÑ‰ª∂
        // =====================================
        
        const JSONGraphEditor = () => {
            // ÂàùÂßãÊï∏Êìö
            const initialData = {
                users: [
                    { id: 1, name: "Alice", age: 25, tags: ["developer", "react", "javascript"], profile: { city: "Tokyo", country: "Japan" } },
                    { id: 2, name: "Bob", age: 30, tags: ["designer", "ui/ux", "figma"], profile: { city: "Seoul", country: "Korea" } }
                ],
                simpleArray: ["apple", "banana", "cherry"],
                numberArray: [1, 2, 3, 4, 5],
                mixedArray: ["text", 42, true, null],
                nestedArray: [["a", "b"], ["c", "d"], ["e", "f"]],
                products: [
                    ["laptop", 1000, 5],
                    ["mouse", 25, 100],
                    ["keyboard", 75, 50]
                ],
                settings: {
                    theme: "dark",
                    notifications: true,
                    features: ["chat", "video", "screen-share"],
                    limits: {
                        maxUsers: 100,
                        maxFiles: 1000
                    }
                },
                simpleValue: "Hello World",
                numberValue: 42,
                booleanValue: true
            };
            
            const [jsonData, setJsonData] = useState(initialData);
            const [selectedTable, setSelectedTable] = useState('');
            const [selectedTableData, setSelectedTableData] = useState([]);
            
            // ÂâµÂª∫Êï∏ÊìöÁÆ°ÁêÜÂô®
            const dataManager = useMemo(() => {
                return new DataChangeManager(jsonData, setJsonData);
            }, []);
            
            // Êõ¥Êñ∞Êï∏ÊìöÁÆ°ÁêÜÂô®ÁöÑÁï∂ÂâçÊï∏Êìö
            useEffect(() => {
                dataManager.currentData = jsonData;
            }, [jsonData, dataManager]);
            
            // ËôïÁêÜË°®Ê†ºÊï∏ÊìöÊõ¥Êñ∞
            const handleTableDataChange = useCallback((newData, tableName) => {
                if (!tableName || !newData) return;
                
                const newJsonData = { ...jsonData };
                const keys = tableName.split('.');
                let current = newJsonData;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    current = current[keys[i]];
                }
                current[keys[keys.length - 1]] = newData;
                
                dataManager.updateData(newJsonData, 'table-editor');
            }, [jsonData, dataManager]);

            return (
                <div className="flex h-screen bg-gray-100">
                    <div className="w-1/2 border-r">
                        <GraphViewer 
                            data={jsonData}
                            onTableSelect={setSelectedTable}
                            onTableDataChange={setSelectedTableData}
                            dataManager={dataManager}
                        />
                    </div>
                    <div className="w-1/2 flex flex-col">
                        <div className="h-1/2 border-b">
                            <TableEditor 
                                tableName={selectedTable}
                                data={selectedTableData}
                                onDataChange={handleTableDataChange}
                                dataManager={dataManager}
                            />
                        </div>
                        <div className="h-1/2">
                            <JsonEditor 
                                data={jsonData}
                                dataManager={dataManager}
                            />
                        </div>
                    </div>
                </div>
            );
        };

        // =====================================
        // üìù JSONÁ∑®ËºØÂô® - ÂÆåÂÖ®ÈáçÊñ∞Ë®≠Ë®à
        // =====================================
        
        const JsonEditor = ({ data, dataManager }) => {
            const [jsonText, setJsonText] = useState('');
            const [error, setError] = useState('');
            const [isFocused, setIsFocused] = useState(false);
            
            const debounceTimeoutRef = useRef(null);
            const editorId = 'json-editor';
            
            // ÂàùÂßãÂåñÂíåÂ§ñÈÉ®Êï∏ÊìöÂêåÊ≠•
            useEffect(() => {
                const dataString = JSON.stringify(data, null, 2);
                setJsonText(dataString);
            }, []);
            
            // Ë®ªÂÜäÂà∞Êï∏ÊìöÁÆ°ÁêÜÂô®
            useEffect(() => {
                const unsubscribe = dataManager.subscribe({
                    id: editorId,
                    onDataChange: (newData) => {
                        if (!isFocused) {
                            const dataString = JSON.stringify(newData, null, 2);
                            setJsonText(dataString);
                        }
                    }
                });
                
                return unsubscribe;
            }, [dataManager, isFocused]);
            
            const handleTextChange = (e) => {
                const text = e.target.value;
                setJsonText(text);
                
                // Ê∏ÖÈô§‰πãÂâçÁöÑÈò≤Êäñ
                if (debounceTimeoutRef.current) {
                    clearTimeout(debounceTimeoutRef.current);
                }
                
                // Á´ãÂç≥Ë™ûÊ≥ïÊ™¢Êü•
                try {
                    JSON.parse(text);
                    setError('');
                    
                    // Èò≤ÊäñÊõ¥Êñ∞
                    debounceTimeoutRef.current = setTimeout(() => {
                        try {
                            const parsed = JSON.parse(text);
                            dataManager.updateData(parsed, editorId);
                        } catch (err) {
                            setError('JSONË™ûÊ≥ïÈåØË™§: ' + err.message);
                        }
                    }, 1000);
                    
                } catch (err) {
                    setError('JSONË™ûÊ≥ïÈåØË™§: ' + err.message);
                }
            };
            
            const handleFocus = () => {
                setIsFocused(true);
            };
            
            const handleBlur = () => {
                setIsFocused(false);
                
                // Á´ãÂç≥Êõ¥Êñ∞
                if (debounceTimeoutRef.current) {
                    clearTimeout(debounceTimeoutRef.current);
                }
                
                try {
                    const parsed = JSON.parse(jsonText);
                    dataManager.updateData(parsed, editorId);
                    setError('');
                } catch (err) {
                    setError('JSONË™ûÊ≥ïÈåØË™§: ' + err.message);
                }
            };
            
            // Ê∏ÖÁêÜ
            useEffect(() => {
                return () => {
                    if (debounceTimeoutRef.current) {
                        clearTimeout(debounceTimeoutRef.current);
                    }
                };
            }, []);

            return (
                <div className="h-full flex flex-col">
                    <div className="p-4 border-b bg-gray-50">
                        <h2 className="text-lg font-semibold">JSON Á∑®ËºØÂô® - v10.0 ÈáçÊñ∞Ë®≠Ë®à</h2>
                        {error && <div className="text-red-500 text-sm mt-1">{error}</div>}
                        <div className="text-xs text-gray-500 mt-1">
                            ÁãÄÊÖã: {isFocused ? 'Á∑®ËºØ‰∏≠' : 'ÂæÖÊ©ü'} | Â≠óÁ¨¶Êï∏: {jsonText.length}
                        </div>
                    </div>
                    <div className="flex-1">
                        <textarea
                            value={jsonText}
                            onChange={handleTextChange}
                            onFocus={handleFocus}
                            onBlur={handleBlur}
                            className="w-full h-full p-4 font-mono text-sm resize-none border-none outline-none"
                            placeholder="Ëº∏ÂÖ• JSON Êï∏Êìö..."
                        />
                    </div>
                </div>
            );
        };

        // =====================================
        // üìä Ë°®Ê†ºÁ∑®ËºØÂô® - ÂÆåÂÖ®ÈáçÊñ∞Ë®≠Ë®à
        // =====================================
        
        const TableEditor = ({ tableName, data, onDataChange, dataManager }) => {
            const [tableData, setTableData] = useState([]);
            const [error, setError] = useState('');
            const [isEditing, setIsEditing] = useState(false);
            
            const debounceTimeoutRef = useRef(null);
            const editorId = 'table-editor';
            
            // ÂàùÂßãÂåñË°®Ê†ºÊï∏Êìö
            useEffect(() => {
                if (data && Array.isArray(data)) {
                    setTableData([...data]);
                    setError('');
                } else {
                    setTableData([]);
                    if (tableName) setError('ÊâÄÈÅ∏Êï∏Êìö‰∏çÊòØ2DÈô£Âàó');
                }
            }, [data, tableName]);
            
            const updateTableData = (newData, immediate = false) => {
                setTableData(newData);
                
                // Ê∏ÖÈô§‰πãÂâçÁöÑÈò≤Êäñ
                if (debounceTimeoutRef.current) {
                    clearTimeout(debounceTimeoutRef.current);
                }
                
                const updateFn = () => {
                    onDataChange(newData, tableName);
                    setIsEditing(false);
                };
                
                if (immediate) {
                    updateFn();
                } else {
                    setIsEditing(true);
                    debounceTimeoutRef.current = setTimeout(updateFn, 500);
                }
            };
            
            const handleCellChange = (rowIndex, colIndex, value) => {
                const newData = [...tableData];
                if (!newData[rowIndex]) newData[rowIndex] = [];
                newData[rowIndex][colIndex] = value;
                updateTableData(newData, false);
            };
            
            const addRow = () => {
                const newData = [...tableData, []];
                updateTableData(newData, true);
            };
            
            const addColumn = () => {
                const newData = tableData.map(row => [...row, '']);
                updateTableData(newData, true);
            };
            
            // Ê∏ÖÁêÜ
            useEffect(() => {
                return () => {
                    if (debounceTimeoutRef.current) {
                        clearTimeout(debounceTimeoutRef.current);
                    }
                };
            }, []);
            
            if (!tableName) {
                return (
                    <div className="h-full flex items-center justify-center text-gray-500">
                        <div className="text-center">
                            <div className="text-4xl mb-4">üìä</div>
                            <p>ÈªûÈÅ∏Âúñ‰∏≠ÁöÑ 2D Èô£ÂàóÁØÄÈªû‰æÜÁ∑®ËºØË°®Ê†º</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col">
                    <div className="p-4 border-b bg-gray-50">
                        <div className="flex justify-between items-center">
                            <div>
                                <h2 className="text-lg font-semibold">Ë°®Ê†ºÁ∑®ËºØÂô® - {tableName}</h2>
                                <div className="text-xs text-gray-500">
                                    ÁãÄÊÖã: {isEditing ? 'Á∑®ËºØ‰∏≠' : 'ÂêåÊ≠•ÂÆåÊàê'} | Ë°åÊï∏: {tableData.length}
                                </div>
                            </div>
                            <div className="space-x-2">
                                <button 
                                    onClick={addRow}
                                    className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                                >
                                    Êñ∞Â¢ûË°å
                                </button>
                                <button 
                                    onClick={addColumn}
                                    className="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600"
                                >
                                    Êñ∞Â¢ûÂàó
                                </button>
                            </div>
                        </div>
                        {error && <div className="text-red-500 text-sm mt-2">{error}</div>}
                    </div>
                    
                    <div className="flex-1 overflow-auto p-4">
                        <div className="inline-block">
                            <table className="border-collapse border border-gray-300">
                                <tbody>
                                    {tableData.map((row, rowIndex) => (
                                        <tr key={rowIndex}>
                                            {Array.from({ length: Math.max(1, Math.max(...tableData.map(r => r.length))) }).map((_, colIndex) => (
                                                <td key={colIndex} className="border border-gray-300">
                                                    <input
                                                        type="text"
                                                        value={row[colIndex] || ''}
                                                        onChange={(e) => handleCellChange(rowIndex, colIndex, e.target.value)}
                                                        className="w-20 p-1 border-none outline-none"
                                                    />
                                                </td>
                                            ))}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        };

        // =====================================
        // üîó ÂÆåÊï¥ÁöÑÂúñÂΩ¢Êü•ÁúãÂô® - ÊÅ¢Âæ©JsonCrackÈ¢®Ê†º
        // =====================================
        
        const GraphViewer = ({ data, onTableSelect, onTableDataChange, dataManager }) => {
            const svgRef = useRef(null);
            const nodePositionsRef = useRef({}); // Ë®ò‰ΩèÁØÄÈªû‰ΩçÁΩÆ
            const isInitialLayoutRef = useRef(true); // ËøΩËπ§ÊòØÂê¶ÁÇ∫ÂàùÊ¨°Â∏ÉÂ±Ä
            
            const extractTables = useCallback((obj, path = '') => {
                const result = [];
                
                const extractNodes = (obj, path, depth = 0, parentId = null) => {
                    const nodes = [];
                    const links = [];
                    
                    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫2DÈô£Âàó
                    const is2DArray = (arr) => {
                        return Array.isArray(arr) && arr.length > 0 && 
                               arr.every(item => Array.isArray(item));
                    };
                    
                    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Ë§áÈõúÁµêÊßãÔºàÈúÄË¶ÅÁî® complex-box È°ØÁ§∫Ôºâ
                    const isComplexStructure = (obj) => {
                        if (Array.isArray(obj)) {
                            // Âè™Êúâ2DÈô£ÂàóÁî®Â∞àÈñÄÁöÑË°®Ê†ºÁØÄÈªûÔºåÊâÄÊúâÂÖ∂‰ªñÈô£ÂàóÈÉΩÁî® complex-box ÂûÇÁõ¥ÂàóË°®È°ØÁ§∫
                            return !is2DArray(obj);
                        }
                        if (typeof obj === 'object' && obj !== null) {
                            // ÊâÄÊúâÁâ©‰ª∂ÈÉΩÁî® complex-box È°ØÁ§∫ÔºåÁ¢∫‰øù‰∏ÄËá¥ÊÄß
                            return true;
                        }
                        return false;
                    };
                    
                    const currentId = path || 'JSON';
                    
                    if (path === '') {
                        nodes.push({
                            id: 'JSON',
                            name: 'JSON',
                            data: obj,
                            type: 'root',
                            depth: 0,
                            parentId: null,
                            x: 0,
                            y: 0
                        });
                        
                        // ËôïÁêÜÊ†πÂ∞çË±°ÁöÑÂ±¨ÊÄß
                        if (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {
                            Object.keys(obj).forEach(key => {
                                const childResult = extractNodes(obj[key], key, 1, 'JSON');
                                nodes.push(...childResult.nodes);
                                links.push(...childResult.links);
                                
                                // ÁÇ∫Ê†πÁØÄÈªûÁöÑÊØèÂÄãÂ±¨ÊÄßÊ∑ªÂä†ÈÄ£Êé•
                                const childNode = childResult.nodes.find(n => n.id === key);
                                if (childNode) {
                                    links.push({
                                        sourceId: 'JSON',
                                        targetId: key,
                                        type: 'root-child'
                                    });
                                }
                            });
                        }
                    } else {
                        // Ê†πÊìöÊï∏ÊìöÈ°ûÂûãÂâµÂª∫ÁØÄÈªû
                        if (Array.isArray(obj)) {
                            if (is2DArray(obj)) {
                                // 2DÈô£Âàó - ÂèØÁ∑®ËºØÁöÑË°®Ê†ºÔºåÂú®Âúñ‰∏≠È°ØÁ§∫ÂØ¶ÈöõË°®Ê†ºÂÖßÂÆπ
                                nodes.push({
                                    id: currentId,
                                    name: path.split('.').pop(),
                                    data: obj,
                                    type: '2d-array',
                                    depth: depth,
                                    parentId: parentId,
                                    x: 0,
                                    y: 0
                                });
                            } else {
                                // ÊâÄÊúâÂÖ∂‰ªñÈô£Âàó - ‰ΩøÁî® complex-box ÂûÇÁõ¥ÂàóË°®È°ØÁ§∫
                                const slots = [];
                                const simpleProps = [];
                                
                                // ÂàÜÊûêÈô£ÂàóÂÖßÂÆπÔºåÁµ±‰∏ÄËôïÁêÜÊâÄÊúâÈ°ûÂûãÁöÑÈô£ÂàóÂÖÉÁ¥†
                                obj.forEach((item, index) => {
                                    const slotId = `${currentId}[${index}]`;
                                    
                                    // Âà§Êñ∑ÂÖÉÁ¥†È°ûÂûã
                                    let itemType = 'primitive';
                                    if (Array.isArray(item)) {
                                        itemType = is2DArray(item) ? '2d-array' : 'array';
                                    } else if (typeof item === 'object' && item !== null) {
                                        itemType = 'object';
                                    } else {
                                        itemType = typeof item;
                                    }
                                    
                                    // Â∞çÊñºÂü∫Êú¨È°ûÂûãÔºåÁõ¥Êé•Âú® properties ‰∏≠È°ØÁ§∫Ôºå‰∏çÂâµÂª∫ slot
                                    if (typeof item !== 'object' || item === null) {
                                        simpleProps.push({
                                            key: `[${index}]`,
                                            value: String(item),
                                            type: typeof item
                                        });
                                    } else {
                                        // Ë§áÈõúÂÖÉÁ¥†ÂâµÂª∫ slot
                                        slots.push({
                                            key: `[${index}]`,
                                            slotId: slotId,
                                            type: itemType
                                        });
                                        
                                        // ÈÅûÊ≠∏ËôïÁêÜË§áÈõúÂÖÉÁ¥†
                                        const childResult = extractNodes(item, slotId, depth + 1, currentId);
                                        nodes.push(...childResult.nodes);
                                        links.push(...childResult.links);
                                        
                                        // Ê∑ªÂä†slotÈÄ£Êé•
                                        links.push({
                                            sourceId: currentId,
                                            targetId: slotId,
                                            slotKey: `[${index}]`,
                                            type: 'slot'
                                        });
                                    }
                                });
                                
                                nodes.push({
                                    id: currentId,
                                    name: path.split('.').pop(),
                                    data: obj,
                                    type: 'complex-box',
                                    subtype: 'array',
                                    depth: depth,
                                    parentId: parentId,
                                    slots: slots,
                                    properties: simpleProps,
                                    x: 0,
                                    y: 0
                                });
                            }
                        } else if (typeof obj === 'object' && obj !== null) {
                            // ÊâÄÊúâÁâ©‰ª∂ÈÉΩ‰ΩøÁî® complex-box ÂûÇÁõ¥ÂàóË°®È°ØÁ§∫
                            const slots = [];
                            const simpleProps = [];
                            
                            Object.keys(obj).forEach(key => {
                                const value = obj[key];
                                const slotId = `${currentId}.${key}`;
                                
                                if (Array.isArray(value) || (typeof value === 'object' && value !== null)) {
                                    // Ë§áÈõúÂ±¨ÊÄß - ÂâµÂª∫ slot
                                    slots.push({
                                        key: key,
                                        slotId: slotId,
                                        type: Array.isArray(value) ? 
                                            (is2DArray(value) ? '2d-array' : 'array') 
                                            : 'object'
                                    });
                                    
                                    const childResult = extractNodes(value, slotId, depth + 1, currentId);
                                    nodes.push(...childResult.nodes);
                                    links.push(...childResult.links);
                                    
                                    links.push({
                                        sourceId: currentId,
                                        targetId: slotId,
                                        slotKey: key,
                                        type: 'slot'
                                    });
                                } else {
                                    // Âü∫Êú¨Â±¨ÊÄß
                                    simpleProps.push({
                                        key: key,
                                        value: String(value),
                                        type: typeof value
                                    });
                                }
                            });
                            
                            nodes.push({
                                id: currentId,
                                name: path.split('.').pop(),
                                data: obj,
                                type: 'complex-box',
                                subtype: 'object',
                                depth: depth,
                                parentId: parentId,
                                slots: slots,
                                properties: simpleProps,
                                x: 0,
                                y: 0
                            });
                        } else {
                            // Âü∫Êú¨È°ûÂûã
                            let nodeType = 'primitive';
                            if (typeof obj === 'string') nodeType = 'string';
                            else if (typeof obj === 'number') nodeType = 'number';
                            else if (typeof obj === 'boolean') nodeType = 'boolean';
                            
                            nodes.push({
                                id: currentId,
                                name: path.split('.').pop(),
                                data: obj,
                                type: nodeType,
                                depth: depth,
                                parentId: parentId,
                                x: 0,
                                y: 0
                            });
                            
                            // Âè™ÁÇ∫Âü∫Êú¨È°ûÂûãÁØÄÈªûÊ∑ªÂä† parent-child ÈÄ£Êé•
                            // complex-box Âíå 2d-array ÁØÄÈªû‰ΩøÁî® slot ÈÄ£Êé•Ôºå‰∏çÈúÄË¶Å parent-child ÈÄ£Êé•
                            if (parentId && (nodeType === 'string' || nodeType === 'number' || nodeType === 'boolean' || nodeType === 'primitive')) {
                                if (!links.some(link => 
                                    link.sourceId === parentId && link.targetId === currentId && link.type !== 'slot'
                                )) {
                                    links.push({
                                        sourceId: parentId,
                                        targetId: currentId,
                                        type: 'parent-child'
                                    });
                                }
                            }
                        }
                    }
                    
                    return { nodes, links };
                };
                
                return extractNodes(obj, path);
            }, []);

            // Ê™¢Ê∏¨Êï∏ÊìöÊòØÂê¶ÁôºÁîüÈáçÂ§ßÁµêÊßãËÆäÂåñ
            const detectMajorStructureChange = useCallback((newData, oldData) => {
                if (!oldData) return true; // È¶ñÊ¨°Âä†Ëºâ
                
                // Ê∑±Â∫¶Ê™¢Êü•ÁµêÊßãËÆäÂåñ
                const checkStructure = (newObj, oldObj, depth = 0) => {
                    if (depth > 3) return false; // ÈôêÂà∂Ê™¢Êü•Ê∑±Â∫¶ÔºåÈÅøÂÖçÈÅéÊ∑±ÁöÑÈÅûÊ≠∏
                    
                    if (typeof newObj !== typeof oldObj) return true;
                    
                    if (Array.isArray(newObj) && Array.isArray(oldObj)) {
                        // Â∞çÊñºÊï∏ÁµÑÔºåÂè™Ê™¢Êü•Èï∑Â∫¶ÁöÑÈáçÂ§ßËÆäÂåñÔºàË∂ÖÈÅé50%ËÆäÂåñÊâçÁÆóÈáçÂ§ßËÆäÂåñÔºâ
                        const lengthChange = Math.abs(newObj.length - oldObj.length);
                        const maxLength = Math.max(newObj.length, oldObj.length);
                        if (maxLength > 0 && lengthChange / maxLength > 0.5) return true;
                        
                        // Ê™¢Êü•Êï∏ÁµÑÂÖÉÁ¥†ÁöÑÁµêÊßãÈ°ûÂûã
                        if (newObj.length > 0 && oldObj.length > 0) {
                            return checkStructure(newObj[0], oldObj[0], depth + 1);
                        }
                        return false;
                    }
                    
                    if (typeof newObj === 'object' && newObj !== null && oldObj !== null) {
                        const newKeys = Object.keys(newObj).sort();
                        const oldKeys = Object.keys(oldObj).sort();
                        
                        // Ê™¢Êü•ÈçµÁöÑËÆäÂåñ
                        if (newKeys.length !== oldKeys.length) return true;
                        for (let i = 0; i < newKeys.length; i++) {
                            if (newKeys[i] !== oldKeys[i]) return true;
                        }
                        
                        // Ê™¢Êü•ÂÄºÁöÑÁµêÊßãÈ°ûÂûã
                        for (const key of newKeys) {
                            if (checkStructure(newObj[key], oldObj[key], depth + 1)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    
                    return false; // Âü∫Êú¨È°ûÂûãÁöÑËÆäÂåñ‰∏çÁÆóÁµêÊßãËÆäÂåñ
                };
                
                return checkStructure(newData, oldData);
            }, []);
            
            const previousDataRef = useRef(null);
            
            useEffect(() => {
                if (!data) return;
                
                // Ê™¢Êü•ÊòØÂê¶ÁÇ∫ÈáçÂ§ßÁµêÊßãËÆäÂåñ
                if (detectMajorStructureChange(data, previousDataRef.current)) {
                    isInitialLayoutRef.current = true;
                    nodePositionsRef.current = {};
                }
                
                previousDataRef.current = data;
                
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();
                
                const width = 800;
                const height = 600;
                
                const container = svg.append('g');
                
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on('zoom', (event) => {
                        container.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                const { nodes, links } = extractTables(data);
                
                // JsonCrack È¢®Ê†ºÁöÑÁ©©ÂÆöÊ∞¥Âπ≥Â∏ÉÂ±Ä - ‰øùÊåÅÁØÄÈªû‰ΩçÁΩÆÁ©©ÂÆö
                const layoutNodes = (nodes) => {
                    const startX = 100;  // Ëµ∑Âßã X ‰ΩçÁΩÆ
                    const centerY = 300; // Áï´Â∏É‰∏≠ÂøÉ Y
                    const levelWidth = 280; // ÊØèÂ±§‰πãÈñìÁöÑÊ∞¥Âπ≥Ë∑ùÈõ¢
                    
                    // Âª∫Á´ãÁà∂Â≠êÈóú‰øÇÊò†Â∞Ñ
                    const childrenMap = {};
                    nodes.forEach(node => {
                        if (!childrenMap[node.parentId]) {
                            childrenMap[node.parentId] = [];
                        }
                        if (node.parentId !== null) {
                            childrenMap[node.parentId].push(node);
                        }
                    });
                    
                    // Ë®àÁÆóÁØÄÈªûÂ∞∫ÂØ∏ÁöÑËºîÂä©ÂáΩÊï∏
                    function getNodeWidth(node) {
                        if (node.type === 'complex-box') {
                            return 220;
                        } else if (node.type === '2d-array') {
                            const data = node.data;
                            if (data && data.length > 0) {
                                const maxCols = Math.max(...data.map(row => row.length));
                                return Math.max(200, maxCols * 80 + 40);
                            }
                            return 200;
                        } else if (node.type === 'root') {
                            return 80;
                        } else {
                            return 160;
                        }
                    }
                    
                    function getNodeHeight(node) {
                        if (node.type === 'complex-box') {
                            const properties = node.properties || [];
                            const slots = node.slots || [];
                            return 30 + properties.length * 20 + slots.length * 20;
                        } else if (node.type === '2d-array') {
                            const data = node.data;
                            if (data && data.length > 0) {
                                return Math.max(80, data.length * 25 + 40);
                            }
                            return 80;
                        } else if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'primitive') {
                            return 50;
                        } else if (node.type === 'root') {
                            return 30;
                        }
                        return 40;
                    }
                    
                    // Â¶ÇÊûú‰∏çÊòØÂàùÊ¨°Â∏ÉÂ±ÄÔºåÂòóË©¶‰øùÊåÅÁèæÊúâ‰ΩçÁΩÆ
                    if (!isInitialLayoutRef.current) {
                        nodes.forEach(node => {
                            const savedPosition = nodePositionsRef.current[node.id];
                            if (savedPosition) {
                                node.x = savedPosition.x;
                                node.y = savedPosition.y;
                                return; // ‰øùÊåÅÁèæÊúâ‰ΩçÁΩÆÔºå‰∏çÈáçÊñ∞Ë®àÁÆó
                            }
                        });
                        
                        // Âè™ÁÇ∫Êñ∞ÁØÄÈªûË®àÁÆó‰ΩçÁΩÆ
                        const newNodes = nodes.filter(node => !nodePositionsRef.current[node.id]);
                        if (newNodes.length > 0) {
                            // ÁÇ∫Êñ∞ÁØÄÈªûÂàÜÈÖç‰ΩçÁΩÆÔºàÂü∫ÊñºÁèæÊúâÁØÄÈªû‰ΩçÁΩÆÔºâ
                            newNodes.forEach(newNode => {
                                // ÊâæÂà∞Áà∂ÁØÄÈªû
                                const parent = nodes.find(n => n.id === newNode.parentId);
                                if (parent) {
                                    // Ë®àÁÆóÁà∂ÁØÄÈªûÂè≥ÂÅ¥ÁöÑ‰ΩçÁΩÆ
                                    const parentLevel = Math.round((parent.x - startX) / levelWidth);
                                    const newX = startX + (parentLevel + 1) * levelWidth;
                                    
                                    // ÊâæÂà∞ÂêåÂ±§Á¥öÁöÑÂÖ∂‰ªñÁØÄÈªûÔºåÈÅøÂÖçÈáçÁñä
                                    const sameLevelNodes = nodes.filter(n => 
                                        Math.abs(n.x - newX) < 50 && n.id !== newNode.id
                                    );
                                    
                                    let newY = parent.y + getNodeHeight(parent) / 2;
                                    if (sameLevelNodes.length > 0) {
                                        // ÊâæÂà∞ÂèØÁî®ÁöÑY‰ΩçÁΩÆ
                                        const usedYPositions = sameLevelNodes.map(n => n.y).sort((a, b) => a - b);
                                        let testY = newY;
                                        const nodeHeight = getNodeHeight(newNode);
                                        
                                        for (let i = 0; i < usedYPositions.length; i++) {
                                            if (testY + nodeHeight + 20 < usedYPositions[i]) {
                                                break;
                                            }
                                            testY = usedYPositions[i] + getNodeHeight(sameLevelNodes.find(n => n.y === usedYPositions[i])) + 20;
                                        }
                                        newY = testY;
                                    }
                                    
                                    newNode.x = newX;
                                    newNode.y = newY;
                                } else {
                                    // Ê≤íÊúâÁà∂ÁØÄÈªûÔºåÂèØËÉΩÊòØÊ†πÁØÄÈªûÊàñÂ≠§Á´ãÁØÄÈªû
                                    newNode.x = startX;
                                    newNode.y = centerY - getNodeHeight(newNode) / 2;
                                }
                            });
                        }
                        
                        // ÂÑ≤Â≠òÊâÄÊúâÁØÄÈªû‰ΩçÁΩÆ
                        nodes.forEach(node => {
                            nodePositionsRef.current[node.id] = { x: node.x, y: node.y };
                        });
                        
                        return nodes;
                    }
                    
                    // ÂàùÊ¨°Â∏ÉÂ±Ä - ‰ΩøÁî®ÂÆåÊï¥ÁöÑÂ∏ÉÂ±ÄÁÆóÊ≥ï
                    const calculateSubtreeHeight = (nodeId, memo = {}) => {
                        if (memo[nodeId] !== undefined) return memo[nodeId];
                        
                        const children = childrenMap[nodeId] || [];
                        if (children.length === 0) {
                            const node = nodes.find(n => n.id === nodeId);
                            memo[nodeId] = getNodeHeight(node) + 40;
                            return memo[nodeId];
                        }
                        
                        let totalHeight = 0;
                        children.forEach(child => {
                            totalHeight += calculateSubtreeHeight(child.id, memo);
                        });
                        
                        memo[nodeId] = Math.max(totalHeight, getNodeHeight(nodes.find(n => n.id === nodeId)) + 40);
                        return memo[nodeId];
                    };
                    
                    const layoutHorizontally = (parentNode, children, level, availableY, availableHeight) => {
                        if (!children || children.length === 0) return;
                        
                        const currentX = startX + level * levelWidth;
                        
                        const sortedChildren = [...children].sort((a, b) => {
                            const heightA = calculateSubtreeHeight(a.id);
                            const heightB = calculateSubtreeHeight(b.id);
                            return heightB - heightA;
                        });
                        
                        let totalSubtreeHeight = 0;
                        sortedChildren.forEach(child => {
                            totalSubtreeHeight += calculateSubtreeHeight(child.id);
                        });
                        
                        const parentCenterY = parentNode ? parentNode.y + getNodeHeight(parentNode) / 2 : centerY;
                        let currentY = parentCenterY - totalSubtreeHeight / 2;
                        
                        sortedChildren.forEach((child, index) => {
                            const subtreeHeight = calculateSubtreeHeight(child.id);
                            const nodeHeight = getNodeHeight(child);
                            
                            child.x = currentX;
                            child.y = currentY + subtreeHeight / 2 - nodeHeight / 2;
                            
                            const grandChildren = childrenMap[child.id] || [];
                            if (grandChildren.length > 0) {
                                layoutHorizontally(child, grandChildren, level + 1, currentY, subtreeHeight);
                            }
                            
                            currentY += subtreeHeight;
                        });
                    };
                    
                    // È¶ñÂÖàÊîæÁΩÆÊ†πÁØÄÈªû
                    const rootNode = nodes.find(n => n.type === 'root');
                    if (rootNode) {
                        rootNode.x = startX;
                        rootNode.y = centerY - getNodeHeight(rootNode) / 2;
                        
                        const rootChildren = childrenMap[rootNode.id] || [];
                        if (rootChildren.length > 0) {
                            layoutHorizontally(rootNode, rootChildren, 1, 0, 600);
                        }
                    }
                    
                    // ÂÑ≤Â≠òÂàùÂßã‰ΩçÁΩÆ‰∏¶Ê®ôË®ò‰∏çÂÜçÊòØÂàùÊ¨°Â∏ÉÂ±Ä
                    nodes.forEach(node => {
                        nodePositionsRef.current[node.id] = { x: node.x, y: node.y };
                    });
                    isInitialLayoutRef.current = false;
                    
                    return nodes;
                };
                
                const layoutedNodes = layoutNodes(nodes);
                
                // Ê∏ÖÁêÜÂ∑≤Âà†Èô§ÁØÄÈªûÁöÑË®òÊÜ∂‰ΩçÁΩÆ
                const currentNodeIds = new Set(nodes.map(n => n.id));
                Object.keys(nodePositionsRef.current).forEach(nodeId => {
                    if (!currentNodeIds.has(nodeId)) {
                        delete nodePositionsRef.current[nodeId];
                    }
                });
                
                // Áπ™Ë£ΩÈÄ£Êé•Á∑ö - ÈÅ©ÈÖçÊ∞¥Âπ≥Â∏ÉÂ±Ä
                const drawLinks = () => {
                    // ÂÖàÊ∏ÖÈô§ÊâÄÊúâÈÄ£Êé•Á∑ö
                    container.selectAll('.connection-line').remove();
                    
                    // Áç≤ÂèñÁØÄÈªûÁöÑÈÄ£Êé•Èªû - ÈáùÂ∞çÊ∞¥Âπ≥Â∏ÉÂ±ÄÂÑ™Âåñ
                    const getNodeConnectionPoint = (sourceNode, targetNode) => {
                        const getNodeDimensions = (n) => {
                            let width = 160, height = 40;
                            
                            if (n.type === 'root') {
                                width = 80; height = 30;
                            } else if (n.type === '2d-array') {
                                const data = n.data;
                                if (data && data.length > 0) {
                                    const maxCols = Math.max(...data.map(row => row.length));
                                    width = Math.max(200, maxCols * 80 + 40);
                                    height = Math.max(80, data.length * 25 + 40);
                                }
                            } else if (n.type === 'complex-box') {
                                width = 220;
                                height = 30 + (n.properties || []).length * 20 + (n.slots || []).length * 20;
                            } else if (n.type === 'string' || n.type === 'number' || n.type === 'boolean' || n.type === 'primitive') {
                                width = 160; height = 50;
                            }
                            
                            return { width, height };
                        };
                        
                        const sourceDim = getNodeDimensions(sourceNode);
                        const targetDim = getNodeDimensions(targetNode);
                        
                        // Â∞çÊñºÊ∞¥Âπ≥Â∏ÉÂ±ÄÔºåÊ∫êÁØÄÈªûÂæûÂè≥ÈÇäÁ∑£ÈÄ£Âá∫ÔºåÁõÆÊ®ôÁØÄÈªûÂæûÂ∑¶ÈÇäÁ∑£ÈÄ£ÂÖ•
                        const sourceCenterY = sourceNode.y + sourceDim.height / 2;
                        const targetCenterY = targetNode.y + targetDim.height / 2;
                        
                        return {
                            source: {
                                x: sourceNode.x + sourceDim.width, // Ê∫êÁØÄÈªûÂè≥ÈÇäÁ∑£
                                y: sourceCenterY
                            },
                            target: {
                                x: targetNode.x, // ÁõÆÊ®ôÁØÄÈªûÂ∑¶ÈÇäÁ∑£
                                y: targetCenterY
                            }
                        };
                    };
                    
                    links.forEach(link => {
                        const sourceNode = layoutedNodes.find(n => n.id === link.sourceId);
                        const targetNode = layoutedNodes.find(n => n.id === link.targetId);
                        
                        if (sourceNode && targetNode) {
                            if (link.type === 'slot') {
                                // Slot ÈÄ£Êé•Á∑ö - Âæû slot ÂúìÈªûÂà∞ÁõÆÊ®ôÁØÄÈªûÂ∑¶ÈÇäÁ∑£
                                const slots = sourceNode.slots || [];
                                const properties = sourceNode.properties || [];
                                const slotIndex = slots.findIndex(slot => slot.key === link.slotKey);
                                
                                if (slotIndex >= 0) {
                                    // slotÂúìÈªûÁöÑÁ≤æÁ¢∫‰ΩçÁΩÆÔºàÁõ∏Â∞çÊñºÁØÄÈªûÔºâ
                                    const sourceX = sourceNode.x + 210; // slot dot ÁöÑ cx ‰ΩçÁΩÆ
                                    const sourceY = sourceNode.y + 45 + properties.length * 20 + slotIndex * 20;
                                    
                                    // ÁõÆÊ®ôÁØÄÈªûÁöÑÂ∑¶ÈÇäÁ∑£‰∏≠ÂøÉ
                                    const targetX = targetNode.x;
                                    const targetY = targetNode.y + getNodeHeight(targetNode) / 2;
                                    
                                    // ÂâµÂª∫ JsonCrack È¢®Ê†ºÁöÑÊ∞¥Âπ≥Êõ≤Á∑ö
                                    const midX = sourceX + (targetX - sourceX) / 2;
                                    
                                    const path = `M ${sourceX},${sourceY} C ${midX},${sourceY} ${midX},${targetY} ${targetX},${targetY}`;
                                    
                                    container.append('path')
                                        .attr('class', 'connection-line slot-connection')
                                        .attr('d', path)
                                        .style('stroke', '#8b5cf6')
                                        .style('stroke-width', 2.5)
                                        .style('fill', 'none')
                                        .style('opacity', 0.8);
                                }
                            } else if (link.type === 'parent-child' || link.type === 'root-child') {
                                // parent-child Âíå root-child ÈÄ£Êé•Á∑ö - JsonCrack È¢®Ê†ºÁöÑÊ∞¥Âπ≥ÈÄ£Êé•
                                const connectionPoints = getNodeConnectionPoint(sourceNode, targetNode);
                                
                                // ÂâµÂª∫Âπ≥ÊªëÁöÑÊ∞¥Âπ≥Êõ≤Á∑ö
                                const sourceX = connectionPoints.source.x;
                                const sourceY = connectionPoints.source.y;
                                const targetX = connectionPoints.target.x;
                                const targetY = connectionPoints.target.y;
                                
                                // Ë®àÁÆó‰∏≠ÈñìÊéßÂà∂ÈªûÔºåÂâµÂª∫Âπ≥ÊªëÁöÑÊ∞¥Âπ≥Êõ≤Á∑ö
                                const midX = sourceX + (targetX - sourceX) / 2;
                                
                                const path = `M ${sourceX},${sourceY} C ${midX},${sourceY} ${midX},${targetY} ${targetX},${targetY}`;
                                
                                container.append('path')
                                    .attr('class', 'connection-line parent-child-connection')
                                    .attr('d', path)
                                    .style('stroke', link.type === 'root-child' ? '#8b5cf6' : '#6b7280')
                                    .style('stroke-width', link.type === 'root-child' ? 3 : 2)
                                    .style('fill', 'none')
                                    .style('opacity', link.type === 'root-child' ? 0.9 : 0.7);
                            }
                        }
                    });
                    
                    // ËºîÂä©ÂáΩÊï∏ - Áç≤ÂèñÁØÄÈªûÈ´òÂ∫¶
                    function getNodeHeight(node) {
                        if (node.type === 'complex-box') {
                            const properties = node.properties || [];
                            const slots = node.slots || [];
                            return 30 + properties.length * 20 + slots.length * 20;
                        } else if (node.type === '2d-array') {
                            const data = node.data;
                            if (data && data.length > 0) {
                                return Math.max(80, data.length * 25 + 40);
                            }
                            return 80;
                        } else if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'primitive') {
                            return 50;
                        } else if (node.type === 'root') {
                            return 30;
                        }
                        return 40;
                    }
                };
                
                drawLinks();
                
                // Áπ™Ë£ΩÁØÄÈªû
                layoutedNodes.forEach(node => {
                    const nodeGroup = container.append('g')
                        .attr('transform', `translate(${node.x}, ${node.y})`);
                    
                    // ÊãñÊãΩË°åÁÇ∫
                    const drag = d3.drag()
                        .on('start', () => {
                            // ÊãñÊãΩÈñãÂßãÊôÇË®òÈåÑÂàùÂßã‰ΩçÁΩÆ
                        })
                        .on('drag', (event) => {
                            // Êõ¥Êñ∞ÁØÄÈªû‰ΩçÁΩÆ
                            node.x = event.x;
                            node.y = event.y;
                            nodeGroup.attr('transform', `translate(${node.x}, ${node.y})`);
                            
                            // ÈáçÊñ∞Áπ™Ë£ΩÊâÄÊúâÈÄ£Êé•Á∑ö
                            drawLinks();
                        })
                        .on('end', () => {
                            // ÊãñÊãΩÁµêÊùüÊôÇÁ¢∫‰øùÈÄ£Êé•Á∑öÊ≠£Á¢∫‰∏¶Êõ¥Êñ∞Ë®òÊÜ∂‰ΩçÁΩÆ
                            drawLinks();
                            // Êõ¥Êñ∞ÁØÄÈªû‰ΩçÁΩÆË®òÊÜ∂
                            nodePositionsRef.current[node.id] = { x: node.x, y: node.y };
                        });
                    
                    nodeGroup.call(drag);
                    
                    if (node.type === '2d-array') {
                        // 2D Èô£ÂàóË°®Ê†ºÁØÄÈªû - È°ØÁ§∫ÂØ¶ÈöõË°®Ê†ºÂÖßÂÆπ
                        const data = node.data;
                        const maxCols = data.length > 0 ? Math.max(...data.map(row => row.length)) : 0;
                        const cellWidth = 80;
                        const cellHeight = 25;
                        const tableWidth = maxCols * cellWidth + 40;
                        const tableHeight = data.length * cellHeight + 40;
                        
                        // ‰∏ªÊ°ÜÊû∂
                        nodeGroup.append('rect')
                            .attr('class', 'node-rect')
                            .attr('width', tableWidth)
                            .attr('height', tableHeight)
                            .attr('fill', '#f8fafc')
                            .attr('stroke', '#94a3b8')
                            .attr('rx', 5)
                            .style('cursor', 'pointer')
                            .on('click', () => {
                                onTableSelect(node.id);
                                onTableDataChange(node.data);
                            });
                        
                        // Ë°®Ê†ºÊ®ôÈ°å
                        nodeGroup.append('rect')
                            .attr('width', tableWidth)
                            .attr('height', 25)
                            .attr('fill', '#475569')
                            .attr('rx', 5);
                        
                        nodeGroup.append('text')
                            .attr('x', tableWidth / 2)
                            .attr('y', 15)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .text(`üìä ${node.name}`)
                            .style('font-size', '12px')
                            .style('fill', 'white')
                            .style('font-weight', 'bold')
                            .style('pointer-events', 'none');
                        
                        // Áπ™Ë£ΩË°®Ê†ºÂÖßÂÆπ
                        data.forEach((row, rowIndex) => {
                            row.forEach((cell, colIndex) => {
                                const x = 20 + colIndex * cellWidth;
                                const y = 30 + rowIndex * cellHeight;
                                
                                // ÂñÆÂÖÉÊ†ºËÉåÊôØ
                                nodeGroup.append('rect')
                                    .attr('class', 'table-cell')
                                    .attr('x', x)
                                    .attr('y', y)
                                    .attr('width', cellWidth)
                                    .attr('height', cellHeight)
                                    .attr('fill', (rowIndex % 2 === 0) ? '#ffffff' : '#f9fafb')
                                    .attr('stroke', '#e5e7eb');
                                
                                // ÂñÆÂÖÉÊ†ºÊñáÂ≠ó
                                let cellText = String(cell);
                                if (cellText.length > 8) {
                                    cellText = cellText.substring(0, 6) + '...';
                                }
                                
                                nodeGroup.append('text')
                                    .attr('x', x + cellWidth / 2)
                                    .attr('y', y + cellHeight / 2)
                                    .attr('text-anchor', 'middle')
                                    .attr('dominant-baseline', 'middle')
                                    .text(cellText)
                                    .style('font-size', '10px')
                                    .style('pointer-events', 'none');
                            });
                        });
                        
                    } else if (node.type === 'complex-box') {
                        // Complex-box ÁØÄÈªûÔºàÂûÇÁõ¥ÂàóË°®Â∏ÉÂ±ÄÔºâ
                        const properties = node.properties || [];
                        const slots = node.slots || [];
                        const totalHeight = 30 + properties.length * 20 + slots.length * 20;
                        
                        // ‰∏ªÊ°Ü
                        nodeGroup.append('rect')
                            .attr('class', 'node-rect')
                            .attr('width', 220)
                            .attr('height', totalHeight)
                            .attr('fill', '#fef3c7')
                            .attr('stroke', '#f59e0b')
                            .attr('rx', 5);
                        
                        // Ê®ôÈ°å
                        nodeGroup.append('rect')
                            .attr('width', 220)
                            .attr('height', 25)
                            .attr('fill', '#f59e0b')
                            .attr('rx', 5);
                        
                        const typeIcon = node.subtype === 'array' ? 'üî¢' : 'üì¶';
                        nodeGroup.append('text')
                            .attr('x', 110)
                            .attr('y', 15)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .text(`${typeIcon} ${node.name}`)
                            .style('font-size', '12px')
                            .style('fill', 'white')
                            .style('font-weight', 'bold');
                        
                        // Âü∫Êú¨Â±¨ÊÄß
                        properties.forEach((prop, index) => {
                            const y = 45 + index * 20;
                            
                            // È°ûÂûãÈ°èËâ≤
                            let color = '#666';
                            if (prop.type === 'string') color = '#059669';
                            else if (prop.type === 'number') color = '#dc2626';
                            else if (prop.type === 'boolean') color = '#7c3aed';
                            
                            nodeGroup.append('text')
                                .attr('x', 10)
                                .attr('y', y)
                                .attr('dominant-baseline', 'middle')
                                .text(`${prop.key}: ${prop.value}`)
                                .style('font-size', '11px')
                                .style('fill', color);
                        });
                        
                        // Slot Â±¨ÊÄß
                        slots.forEach((slot, index) => {
                            const y = 45 + properties.length * 20 + index * 20;
                            
                            // Slot ÂúìÈªû
                            let dotColor = '#8b5cf6';
                            if (slot.type === 'array') dotColor = '#3b82f6';
                            else if (slot.type === '2d-array') dotColor = '#10b981';
                            else if (slot.type === 'object') dotColor = '#f59e0b';
                            
                            nodeGroup.append('circle')
                                .attr('class', 'slot-dot')
                                .attr('cx', 210)  // Ë™øÊï¥Âà∞Ê≠£Á¢∫‰ΩçÁΩÆ (220ÂØ¨Â∫¶ - 10ÂÅèÁßª)
                                .attr('cy', y)
                                .attr('r', 4)
                                .attr('fill', dotColor)
                                .attr('stroke', '#fff')
                                .attr('stroke-width', 2);
                            
                            // Slot Ê®ôÁ±§
                            nodeGroup.append('text')
                                .attr('x', 10)
                                .attr('y', y)
                                .attr('dominant-baseline', 'middle')
                                .text(slot.key)
                                .style('font-size', '11px')
                                .style('fill', '#374151');
                        });
                        
                    } else if (node.type === 'root') {
                        // Ê†πÁØÄÈªû
                        nodeGroup.append('rect')
                            .attr('class', 'node-rect')
                            .attr('width', 80)
                            .attr('height', 30)
                            .attr('fill', '#ddd6fe')
                            .attr('stroke', '#8b5cf6')
                            .attr('rx', 5);
                        
                        nodeGroup.append('text')
                            .attr('x', 40)
                            .attr('y', 20)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .text('üåê JSON')
                            .style('font-size', '12px')
                            .style('font-weight', 'bold');
                    } else {
                        // ÂÖ∂‰ªñÁØÄÈªûÈ°ûÂûã
                        let color = '#f3f4f6';
                        let borderColor = '#9ca3af';
                        let icon = 'üìÑ';
                        
                        if (node.type === 'string') {
                            color = '#dcfce7'; borderColor = '#16a34a'; icon = 'üìù';
                        } else if (node.type === 'number') {
                            color = '#fecaca'; borderColor = '#dc2626'; icon = 'üî¢';
                        } else if (node.type === 'boolean') {
                            color = '#e0e7ff'; borderColor = '#6366f1'; icon = '‚úÖ';
                        } else if (node.type === 'array') {
                            color = '#dbeafe'; borderColor = '#2563eb'; icon = 'üìã';
                        } else if (node.type === 'object') {
                            color = '#fed7aa'; borderColor = '#ea580c'; icon = 'üì¶';
                        }
                        
                        nodeGroup.append('rect')
                            .attr('class', 'node-rect')
                            .attr('width', 160)
                            .attr('height', 50)
                            .attr('fill', color)
                            .attr('stroke', borderColor)
                            .attr('rx', 5);
                        
                        if (node.type === 'primitive' || node.type === 'string' || node.type === 'number' || node.type === 'boolean') {
                            // Âü∫Êú¨È°ûÂûãÁØÄÈªûÔºöÈ°ØÁ§∫ key Âíå value
                            // Á¨¨‰∏ÄË°åÔºökey ÂêçÁ®±
                            nodeGroup.append('text')
                                .attr('x', 80)
                                .attr('y', 18)
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .text(`${icon} ${node.name}`)
                                .style('font-size', '11px')
                                .style('font-weight', 'bold')
                                .style('pointer-events', 'none');
                            
                            // Á¨¨‰∫åË°åÔºövalue ÂÄº
                            let valueText = String(node.data);
                            if (valueText.length > 20) {
                                valueText = valueText.substring(0, 18) + '...';
                            }
                            
                            nodeGroup.append('text')
                                .attr('x', 80)
                                .attr('y', 35)
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .text(valueText)
                                .style('font-size', '10px')
                                .style('fill', '#666')
                                .style('pointer-events', 'none');
                        } else {
                            // ÂÖ∂‰ªñÈ°ûÂûãÁØÄÈªûÔºöÂè™È°ØÁ§∫ÂêçÁ®±
                            nodeGroup.append('text')
                                .attr('x', 80)
                                .attr('y', 25)
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .text(`${icon} ${node.name}`)
                                .style('font-size', '11px')
                                .style('pointer-events', 'none');
                        }
                    }
                });
                
            }, [data, extractTables, detectMajorStructureChange]);
            
            return (
                <div className="h-full bg-white">
                    <div className="p-4 border-b bg-gray-50">
                        <h2 className="text-lg font-semibold">Èóú‰øÇÂúñ (Graph View) - v10.0 ÂÆåÊï¥ÊÅ¢Âæ©</h2>
                        <div className="text-xs text-gray-500 mt-1">
                            JsonCrackÈ¢®Ê†º + Á©©ÂÆöÁ∑®ËºØ + ÂÆåÊï¥Ë¶ñË¶∫Âåñ
                        </div>
                    </div>
                    <div className="graph-container h-full">
                        <svg ref={svgRef} width="100%" height="100%" />
                    </div>
                </div>
            );
        };

        // Ê∏≤ÊüìÊáâÁî®
        ReactDOM.render(<JSONGraphEditor />, document.getElementById('root'));
    </script>
</body>
</html>